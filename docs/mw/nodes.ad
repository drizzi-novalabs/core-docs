[[middleware-nodes]]
== Nodes
A node is nothing but a process that runs on a module and that communicate with other nodes using a
topic based publish/subscribe pattern (see https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern[Wikipedia]).

From the source code point of view a node can be defined in two different ways:

* as subclass of `Core::MW::CoreNode`
* as an OS thread

The first approach permits to control the execution flow and is the preferred way to implement a node. +
The latter approach, whilst apparently simpler, does not offer any control on the Node lifecycle.

Nodes defined as subclasses of `Core::MW::CoreNode` share other important features:

* they can be described using a JSON file, allowing automatic code generation
* they can be easily configured by means of a configuration system


[[middleware-corenode]]
=== CoreNode
[[middleware-corenode-icorenode]]
==== ICoreNode & the node lifecycle
The `Core::MW::ICoreNode` interface describes the lifecycle of a node.

.Interface `ICoreNode`
[source,cpp,numbered]
----
class ICoreNode
{
public:
	enum class State {
		NONE, // Node has not been set up
		SET_UP, // wait
		INITIALIZING, // -> onInitialize
		INITIALIZED, // wait
		CONFIGURING, // -> onConfigure
		CONFIGURED, // wait
		PREPARING_HW, // -> onPrepareHW
		HW_READY, // wait
		PREPARING_MW, // -> onPrepareMW
		MW_READY, // wait
		IDLE, // wait
		STARTING, // -> onStart
		LOOPING, // -> onLoop
		STOPPING, // -> onStop
		FINALIZING, // -> onFinalize
		ERROR, // wait forever
		TEARING_DOWN // killing
	};

	enum class Action {
		INITIALIZE, CONFIGURE, PREPARE_HW, PREPARE_MW, START, STOP, FINALIZE
	};

	virtual bool
	setup() = 0;

	virtual bool
	teardown() = 0;

	virtual bool
	execute(
			Action what
	) = 0;

	virtual State
	state() = 0;


	virtual ~ICoreNode() {}

protected:
	virtual bool
	onInitialize() = 0;

	virtual bool
	onConfigure() = 0;

	virtual bool
	onPrepareHW() = 0;

	virtual bool
	onPrepareMW() = 0;

	virtual bool
	onStart() = 0;

	virtual bool
	onLoop() = 0;

	virtual bool
	onStop() = 0;

	virtual bool
	onError() = 0;

	virtual bool
	onFinalize() = 0;


protected:
	ICoreNode() :
		_currentState(State::NONE)
	{}

	State _currentState;
};
----

When are firstly created, an `Core::MW::ICoreNode` derived object must be in a `ICoreNode::State::NONE` state.
Calling `ICoreNode::setup()` will set up the node execution. State will change to `ICoreNode::State::SET_UP` once the node is ready.

Then is it possible to cycle all the states using `ICoreNode::execute()`. +
The order of the actions to execute must be exactly:

. `ICoreNode::Action::INITIALIZE`
. `ICoreNode::Action::CONFIGURE`
. `ICoreNode::Action::PREPARE_HW`
. `ICoreNode::Action::PREPARE_MW`
. `ICoreNode::Action::START`
. `ICoreNode::Action::STOP`
. `ICoreNode::Action::FINALIZE`

`ICoreNode::execute()` must return `false` if an out of order action is requested.

To every action corresponds an event: `ICoreNode::onInitialize()`,
`ICoreNode::onConfigure()`, `ICoreNode::onPrepareHW()`,
`ICoreNode::onPrepareMW()`, `ICoreNode::onStart()`,
`ICoreNode::onLoop()`, `ICoreNode::onStop()`, `ICoreNode::onFinalize()`.

The meaning of the events can be summarized as follows:

* `ICoreNode::onInitialize()`: memory allocation, default memeber value
assignement, ...
* `ICoreNode::onConfigure()`: configuration, ...
* `ICoreNode::onPrepareHW()`: hardware setup, device probing, ...
* `ICoreNode::onPrepareMW()`: publishers advertising and subscribers
subscribing, callback settings, ...
* `ICoreNode::onStart()`: hardware starting, ...
* `ICoreNode::onLoop()`: the main loop
* `ICoreNode::onStop()`: hardware stopping, ...
* `ICoreNode::onFinalize()`: memory deallocation, ...

Whenever an unrecoverable error occurs (i.e.: when an event member function returns `false`), the state of the node must become `ICoreNode::State::ERROR` and `ICoreNode::onError()` event must be called.
The only way to recover must then be to tear down the node, calling `ICoreNode::teardown()`. +
`ICoreNode::teardown()` must also be called when a `ICoreNode `object is destroyed.

See <<icorenode-state-machine-diagram>> for a description of the state transitions.

.`ICoreNode` state machine
[[icorenode-state-machine-diagram]]
[plantuml, corenode-state-machine-diagram,"{plantuml_format}", alt="ICoreNode state machine"]
----
[*] -> NONE

INITIALIZING: onInitialize()
CONFIGURING: onConfigure()
PREPARING_HW: onPrepareHW()
PREPARING_MW: onPrepareMW()
FINALIZING: onFinalize()

NONE -> SET_UP : setup()

SET_UP --> INITIALIZING : execute(INITIALIZE)

INITIALIZING --> INTIALIZED: [onInitialize == true]
INITIALIZING --> ERROR: [onInitialize == false]

INTIALIZED --> CONFIGURING : execute(CONFIGURE)

CONFIGURING --> CONFIGURED : [onConfigure() == true]
CONFIGURING --> ERROR : [onConfigure() == false]

CONFIGURED --> PREPARING_HW : execute(PREPARE_HW)

PREPARING_HW --> HW_READY : [onPrepareHW() == true]
PREPARING_HW --> ERROR : [onPrepareHW() == false]

HW_READY --> PREPARING_MW : execute(PREPARE_MW)

PREPARING_MW --> MW_READY : [onPrepareMW() == true]
PREPARING_MW --> ERROR : [onPrepareMW() == false]

MW_READY --> IDLE

state IDLE {
  STARTING: onStart()
  LOOPING: onLoop()
  STOPPING: onStop()
  
  [*] --> STARTING: execute(START)
  
  STARTING --> LOOPING: [onStart() == true]
  STARTING --> ERROR: [onStart() == false]

  LOOPING -> LOOPING
  LOOPING --> STOPPING: execute(STOP)
  
  STOPPING --> [*]: [onStop() == true]
  STOPPING --> ERROR: [onStop() == false]
}

IDLE -d-> FINALIZING: execute(FINALIZE)

FINALIZING -up-> SET_UP: [onFinalize() == true]
FINALIZING --> ERROR: [onFinalize() == false]
----

NOTE: For clarity in <<icorenode-state-machine-diagram>> there is no reference to `Core::MW::ICoreNode::teardown()`,
but it must always be possible to call it in every moment. +
The node must switch to a `ICoreNode::State::TEARING_DOWN` state and then, to `ICoreNode::State::NONE`.

[[middleware-corenode]]
==== CoreNode
.`CoreNode` header file
[source,cpp,numbered]
----
#pragma once

#include <Core/MW/namespace.hpp>

#include <Core/MW/Thread.hpp>
#include <Core/MW/Condition.hpp>
#include <Core/MW/Mutex.hpp>
#include <Core/MW/Node.hpp>

#include <Core/MW/ICoreNode.hpp>

NAMESPACE_CORE_MW_BEGIN

class CoreNode:
	public ICoreNode,
	protected Core::MW::Node
{
public:
	virtual ~CoreNode() {}

	CoreNode(
			const char*                    name,
			Core::MW::Thread::PriorityEnum priority = Core::MW::Thread::PriorityEnum::NORMAL
	);

...	
----

The `Core::MW::CoreNode` class offers the developer the possibility to cleanly implement all the possible aspects related to a node by implementing the `Core::MW::ICoreNode` interface.

Calling `CoreNode::setup()` will create the node execution thread.
State will change to `CoreNode::State::SET_UP` once the thread has been created.

The event member functions by default return `true`, so it is not needed to implement these in `Core::MW::CoreNode` derived classes.

Implementing a new node requires to extend `Core::MW::CoreNode`, and to override the default event member functions as required. +
`Core::MW::CoreNode` constructor takes 2 arguments, the node name and the node thread priority.

`Core::MW::CoreNode` extends a lower-level `Core::MW::Node` class. +
This class offers methods to notify the system that topic are going to be published and/or subscribed.

.`advertise` and `publish` methods
[source,cpp,numbered]
----
	template <typename MT>
	bool
	advertise(
			Publisher<MT>& pub,
			const char*    namep,
			const Time&    publish_timeout = Time::INFINITE
	);


	template <typename MT>
	bool
	subscribe(
			SubscriberExtBuf<MT>& sub,
			const char*           namep,
			MT                    mgpool_buf[]
	);


	template <typename MT, unsigned QL>
	bool
	subscribe(
			Subscriber<MT, QL>& sub,
			const char* namep
	);
----

A `Core::MW::CoreNode` object can be added to a `Core::MW::CoreNodeManager` (such as a `Core::MW::CoreModule`). +
In this way all the nodes lifecycles are syncronized.
It is also easier and more concise than calling all the `execute()` while checking for the return value and states.

.A node derived from `CoreNode`
=================
.Header file for `led::Publisher` node
[source,cpp,numbered]
----
#pragma once

#include <Core/MW/CoreNode.hpp>
#include <Core/MW/Publisher.hpp>

#include <common_msgs/Led.hpp>
#include <led/PublisherConfiguration.hpp>

#include <array>

namespace led {
	class Publisher:
		public Core::MW::CoreNode
	{
public: // CONSTRUCTOR and DESTRUCTOR
		Publisher(
				const char*                    name,
				Core::MW::Thread::PriorityEnum priority = Core::MW::Thread::PriorityEnum::NORMAL
		);
		virtual
		~Publisher();

public: // CONFIGURATION
		PublisherConfiguration configuration;

private: // PUBLISHERS and SUBSCRIBERS
		Core::MW::Publisher<common_msgs::Led> _publisher;

private: // PRIVATE MEMBERS
		uint32_t _toggle;

private: // EVENTS
		bool
		onPrepareMW();

		bool
		onLoop();
	};
}
----
=================

[[os-thread]]
=== OS thread
In this approach a node is defined directly as a thread.


.A node defined as an OS thread
=================
.Thread Code
[source,cpp,numbered]
----
void
test_subscriber_node(
		void* arg
)
{
	Core::MW::Node node("test_sub");
	Core::MW::Subscriber<common_msgs::String64, 5> sub;
	common_msgs::String64* msgp;

	(void)arg;
	chRegSetThreadName("test_sub");

	node.subscribe(sub, "test");

	for (;;) {
		node.spin(Core::MW::Time::ms(1000));

		if (sub.fetch(msgp)) {
			module.stream.printf("%s\r\n", msgp->data);
			sub.release(*msgp);
		}
	}
}
----

And later on, create a thread with it.

.Thread creation
[source,cpp,numbered]
----
...
Core::MW::Thread::create_heap(NULL, THD_WORKING_AREA_SIZE(1024), NORMALPRIO, test_subscriber_node, nullptr);
...
----
=================