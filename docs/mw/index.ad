:toc: left

= Core Middleware
Davide Rizzi <d.rizzi@novalabs.io>
v1.0, 2016-04-13

[[middleware-reference]]
Middleware reference
--------------------
[quote, Lt. Cmdr. Data]
____
My programming may be inadequate to the task.
____

[quote, Counselor Deanna Troy, 'Star Trek - The Next Generation: In Theory']
____
We're all more than the sum of our parts, Data. + 
You'll have to be more than the sum of your programming. 
____

[[middleware-overview]]
Overview
~~~~~~~~

The Core Middleware is a topic-based publish/subscribe middleware (see
https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern[Wikipedia])
that makes it possible to speed up the software development by
leveraging on code reuse.

Applications are built connecting together logical blocks (nodes) by
means of named communication channels (topics). Each topic has its own
specific message type. Each node can transmit (publish) on and can
receive (subscribe) from any channel (topic).

In this document a more in-depth description of the following objects will be given.

. Messages
. Publishers
. Subscribers
. Nodes

[[middleware-publishers-and-subscribers]]
Publishers and Subscribers
~~~~~~~~~~~~~~~~~~~~~~~~~~

[[middleware-publisher]]
Publisher
^^^^^^^^^
A publisher is defined as an instance of `Core::MW::Publisher<typename MessageType>` class.

The class template must be specialized using the message type of the topic it will publish to.

.How to publish data
[source,cpp,numbered]
----
common_msgs::Led* msg;

Core::MW::Publisher<common_msgs::Led> publisher;

if (publisher.alloc(msg)) { // <1>

	msgp->led   = 4;    // <2>
	msgp->value = 0;

	if (!publisher.publish(*msg)) { // <3>
		...
	}
}
----		
<1> ask the publisher to allocate a message
<2> valorize the message
<3> publish it


The `Core::MW::Publisher::alloc()` method will return false where there are no subscribers to the topic. +
The `Core::MW::Publisher::publish()` method will return false when TODO.

NOTE: It is up to the node to tell the system that the publisher exists. This will be discussed in the <<middleware-nodes>> section.

[[middleware-subscriber]]
Subscriber
^^^^^^^^^^
A subscriber is defined as an instance of `Core::MW::Subscriber<typename MessageType, unsigned QUEUE_LENGTH>` class.

The class template must be specialized using the message type of the topic it will subscribe to and the length of the message queue.
The message queue length (`QUEUE_LENGTH`) _must be_ at least 2.

There are 2 ways to consume the data received:

* registering a callback
* using `Core::MW::Subscriber::fetch()`

NOTE: It is up to the node to tell the system that the subscriber exists. This will be discussed in the <<middleware-nodes>> section.

[[middleware-subscriber-callback]]
Callback
++++++++

It is possible to register a subscriber callback the Middleware will
call on its spin() method (more on this later).

The callback function signature for a
`Core::MW::Subscriber<typename MessageType, unsigned QUEUE_LENGTH>`
subscriber is:

.Callback data type
[source,cpp,numbered]
----
typedef bool (* Callback)(
	const MessageType& msg,
	Node*              node
);
----

The callback function can be registered using `Core::MW::Subscriber::set_callback()` method.

The node parameter is required to easily allow multiple instance of the
subscriber (as the callback is a C function-pointer).

.Callback function example
[source,cpp,numbered]
----

...

subscriber.set_callback(LedSubscriber::callback); <1>

...

bool
LedSubscriber::callback(
		const common_msgs::Led& msg,
		Core::MW::Node*         node
)
{
	LedSubscriber* _this = static_cast<LedSubscriber*>(node); // <2>

	_this->setLedValue(msg.value);
}
----
<1> register the callback
<2> pointer to instance of the node

TIP: If the callback is a class member function, it _MUST_ be made `static` (to exclude the parameter `this` from its signature).

[[middleware-subscriber-fetch]]
fetch()
+++++++
[source,cpp,numbered]
----
common_msgs::Led* msg;

if (subscriber.fetch(msg)) {
	setLedValue(msg.value);
}
----

The `Core::MW::Subscriber::fetch()` method will return false where there are no messages in the queue.


[[middleware-nodes]]
Nodes
~~~~~
A node is nothing but a process that runs on a module and that communicate with other nodes using a
topic based publish/subscribe pattern (see https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern[Wikipedia]).

From the source code point of view a node can be defined in two different ways:

* as subclass of `Core::MW::CoreNode`
* as an OS thread

The first approach permits to control the execution flow and is the preferred way to implement a node. +
The latter approach, whilst apparently simpler, does not offer any control on the Node lifecycle.

Nodes defined as subclasses of `Core::MW::CoreNode` share other important features:

* they can be described using a JSON file, allowing automatic code generation
* they can be easily configured by means of a configuration system


[[middleware-corenode]]
CoreNode
^^^^^^^^

[[middleware-corenode-icorenode]]
`ICoreNode` & the node lifecycle
++++++++++++++++++++++++++++++++

The `Core::MW::ICoreNode` interface describes the lifecycle of a node.

.Interface `ICoreNode`
[source,cpp,numbered]
----
class ICoreNode
{
public:
	enum class State {
		NONE, // Node has not been set up
		SET_UP, // wait
		INITIALIZING, // -> onInitialize
		INITIALIZED, // wait
		CONFIGURING, // -> onConfigure
		CONFIGURED, // wait
		PREPARING_HW, // -> onPrepareHW
		HW_READY, // wait
		PREPARING_MW, // -> onPrepareMW
		MW_READY, // wait
		IDLE, // wait
		STARTING, // -> onStart
		LOOPING, // -> onLoop
		STOPPING, // -> onStop
		FINALIZING, // -> onFinalize
		ERROR, // wait forever
		TEARING_DOWN // killing
	};

	enum class Action {
		INITIALIZE, CONFIGURE, PREPARE_HW, PREPARE_MW, START, STOP, FINALIZE
	};

	virtual bool
	setup() = 0;

	virtual bool
	teardown() = 0;

	virtual bool
	execute(
			Action what
	) = 0;

	virtual State
	state() = 0;


	virtual ~ICoreNode() {}

protected:
	virtual bool
	onInitialize() = 0;

	virtual bool
	onConfigure() = 0;

	virtual bool
	onPrepareHW() = 0;

	virtual bool
	onPrepareMW() = 0;

	virtual bool
	onStart() = 0;

	virtual bool
	onLoop() = 0;

	virtual bool
	onStop() = 0;

	virtual bool
	onError() = 0;

	virtual bool
	onFinalize() = 0;


protected:
	ICoreNode() :
		_currentState(State::NONE)
	{}

	State _currentState;
};
----

When are firstly created, `Core::MW::ICoreNode` must be in a `ICoreNode::State::NONE` state.
Calling `ICoreNode::setup()` will set up the node execution. State will change to `ICoreNode::State::SET_UP` once the node is ready.

Then is it possible to cycle all the states using `ICoreNode::execute()`. +
The order of the actions to execute must be exactly:

. `ICoreNode::Action::INITIALIZE`
. `ICoreNode::Action::CONFIGURE`
. `ICoreNode::Action::PREPARE_HW`
. `ICoreNode::Action::PREPARE_MW`
. `ICoreNode::Action::START`
. `ICoreNode::Action::STOP`
. `ICoreNode::Action::FINALIZE`

`ICoreNode::execute()` must return `false` if an out of order action is requested.

To every action corresponds an event: `ICoreNode::onInitialize()`,
`ICoreNode::onConfigure()`, `ICoreNode::onPrepareHW()`,
`ICoreNode::onPrepareMW()`, `ICoreNode::onStart()`,
`ICoreNode::onLoop()`, `ICoreNode::onStop()`, `ICoreNode::onFinalize()`.

The meaning of the events can be summarized as follows:

* `ICoreNode::onInitialize()`: memory allocation, default memeber value
assignement, ...
* `ICoreNode::onConfigure()`: configuration, ...
* `ICoreNode::onPrepareHW()`: hardware setup, device probing, ...
* `ICoreNode::onPrepareMW()`: publishers advertising and subscribers
subscribing, callback settings, ...
* `ICoreNode::onStart()`: hardware starting, ...
* `ICoreNode::onLoop()`: the main loop
* `ICoreNode::onStop()`: hardware stopping, ...
* `ICoreNode::onFinalize()`: memory deallocation, ...

Whenever an unrecoverable error occurs (i.e.: when an event member function returns `false`), the state of the node must become `ICoreNode::State::ERROR` and `ICoreNode::onError()` event must be called.
The only way to recover must then be to tear down the node, calling `ICoreNode::teardown()`. +
`ICoreNode::teardown()` must also be called when a CoreNode object is destroyed.

See <<icorenode-state-machine-diagram>> for a description of the state transitions.

.`ICoreNode` state machine
[[icorenode-state-machine-diagram]]
[plantuml, corenode-state-machine-diagram,"{plantuml_format}", alt="Class diagram"]
----
[*] -> NONE

INITIALIZING: onInitialize()
CONFIGURING: onConfigure()
PREPARING_HW: onPrepareHW()
PREPARING_MW: onPrepareMW()
FINALIZING: onFinalize()

NONE -> SET_UP : setup()

SET_UP --> INITIALIZING : execute(INITIALIZE)

INITIALIZING --> INTIALIZED: [onInitialize == true]
INITIALIZING --> ERROR: [onInitialize == false]

INTIALIZED --> CONFIGURING : execute(CONFIGURE)

CONFIGURING --> CONFIGURED : [onConfigure() == true]
CONFIGURING --> ERROR : [onConfigure() == false]

CONFIGURED --> PREPARING_HW : execute(PREPARE_HW)

PREPARING_HW --> HW_READY : [onPrepareHW() == true]
PREPARING_HW --> ERROR : [onPrepareHW() == false]

HW_READY --> PREPARING_MW : execute(PREPARE_MW)

PREPARING_MW --> MW_READY : [onPrepareMW() == true]
PREPARING_MW --> ERROR : [onPrepareMW() == false]

MW_READY --> IDLE

state IDLE {
  STARTING: onStart()
  LOOPING: onLoop()
  STOPPING: onStop()
  
  [*] --> STARTING: execute(START)
  
  STARTING --> LOOPING: [onStart() == true]
  STARTING --> ERROR: [onStart() == false]

  LOOPING -> LOOPING
  LOOPING --> STOPPING: execute(STOP)
  
  STOPPING --> [*]: [onStop() == true]
  STOPPING --> ERROR: [onStop() == false]
}

IDLE -d-> FINALIZING: execute(FINALIZE)

FINALIZING -up-> SET_UP: [onFinalize() == true]
FINALIZING --> ERROR: [onFinalize() == false]
----

NOTE: For clarity in <<icorenode-state-machine-diagram>> there is no reference to `Core::MW::ICoreNode::teardown()`,
but it must always be possible to call it in every moment. +
The node must switch to a `ICoreNode::State::TEARING_DOWN` state and then, to `ICoreNode::State::NONE`.

[[middleware-corenode]]
CoreNode
++++++++
.`CoreNode` header file
[source,cpp,numbered]
----
#pragma once

#include <Core/MW/namespace.hpp>

#include <Core/MW/Thread.hpp>
#include <Core/MW/Condition.hpp>
#include <Core/MW/Mutex.hpp>
#include <Core/MW/Node.hpp>

#include <Core/MW/ICoreNode.hpp>

NAMESPACE_CORE_MW_BEGIN

class CoreNode:
	public ICoreNode,
	protected Core::MW::Node
{
public:
	virtual ~CoreNode() {}

	CoreNode(
			const char*                    name,
			Core::MW::Thread::PriorityEnum priority = Core::MW::Thread::PriorityEnum::NORMAL
	);

...	
----

The `Core::MW::CoreNode` class offers the developer the possibility to cleanly implement all the possible aspects related to a node by implementing the `Core::MW::ICoreNode` interface.

Calling `CoreNode::setup()` will create the node execution thread.
State will change to `CoreNode::State::SET_UP` once the thread has been created.

The event member functions by default return `true`, so it is not needed to implement these in `Core::MW::CoreNode` derived classes.

Implementing a new node requires to extend `Core::MW::CoreNode`, and to override the default event member functions as required. +
`Core::MW::CoreNode` constructor takes 2 arguments, the node name and the node thread priority.

`Core::MW::CoreNode` extends a lower-level `Core::MW::Node` class. +
This class offers methods to notify the system that topic are going to be published and/or subscribed.

.`advertise` and `publish` methods
[source,cpp,numbered]
----
	template <typename MT>
	bool
	advertise(
			Publisher<MT>& pub,
			const char*    namep,
			const Time&    publish_timeout = Time::INFINITE
	);


	template <typename MT>
	bool
	subscribe(
			SubscriberExtBuf<MT>& sub,
			const char*           namep,
			MT                    mgpool_buf[]
	);


	template <typename MT, unsigned QL>
	bool
	subscribe(
			Subscriber<MT, QL>& sub,
			const char* namep
	);
----

A `Core::MW::CoreNode` object can be added to a `Core::MW::CoreNodeManager` (such as a `Core::MW::CoreModule`). +
In this way all the nodes lifecycles are syncronized.
It is also easier and more concise than calling all the `execute()` while checking for the return value and states.

.Example: `CoreNode` derived node (header file)
[source,cpp,numbered]
----
#pragma once

#include <Core/MW/CoreNode.hpp>
#include <Core/MW/Publisher.hpp>

#include <common_msgs/Led.hpp>
#include <led/PublisherConfiguration.hpp>

#include <array>

namespace led {
	class Publisher:
		public Core::MW::CoreNode
	{
public: // CONSTRUCTOR and DESTRUCTOR
		Publisher(
				const char*                    name,
				Core::MW::Thread::PriorityEnum priority = Core::MW::Thread::PriorityEnum::NORMAL
		);
		virtual
		~Publisher();

public: // CONFIGURATION
		PublisherConfiguration configuration;

private: // PUBLISHERS and SUBSCRIBERS
		Core::MW::Publisher<common_msgs::Led> _publisher;

private: // PRIVATE MEMBERS
		uint32_t _toggle;

private: // EVENTS
		bool
		onPrepareMW();

		bool
		onLoop();
	};
}
----

[[os-thread]]
OS thread
^^^^^^^^^

In this approach a node is defined directly as a thread.


.OS thread: node
[source,cpp,numbered]
----
void
test_subscriber_node(
		void* arg
)
{
	Core::MW::Node node("test_sub");
	Core::MW::Subscriber<common_msgs::String64, 5> sub;
	common_msgs::String64* msgp;

	(void)arg;
	chRegSetThreadName("test_sub");

	node.subscribe(sub, "test");

	for (;;) {
		node.spin(Core::MW::Time::ms(1000));

		if (sub.fetch(msgp)) {
			module.stream.printf("%s\r\n", msgp->data);
			sub.release(*msgp);
		}
	}
}
----

And later on, create a thread with it.

.OS thread: thread
[source,cpp,numbered]
----
...
Core::MW::Thread::create_heap(NULL, THD_WORKING_AREA_SIZE(1024), NORMALPRIO, test_subscriber_node, nullptr);
...
----

Configurations
++++++++++++++
`Core::MW::CoreConfiguration` class implements a kind-of reflection system, which allows to access derived class members by their name:

[source,cpp,numbered]
----
led::LedPublisherConfiguration configuration;

configuration.led = 3;
----

is the same as

[source,cpp,numbered]
----
led::LedPublisherConfiguration configuration;

configuration["led"] = 3;
----

This is useful for a runtime configuration of the node.

[WARNING]
====
As this system relies on type deduction for template argument and return value types, special care must be used in assignments using the `[]` operator.
This is specially true in assignments of numeric literals.

It is better to always force the type by using an explicit cast.
====